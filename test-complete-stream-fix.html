<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Stream Error Fix Test</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; }
        .test-result { margin: 10px 0; padding: 15px; border-radius: 8px; border-left: 5px solid; }
        .success { background-color: #d4edda; border-color: #28a745; color: #155724; }
        .error { background-color: #f8d7da; border-color: #dc3545; color: #721c24; }
        .info { background-color: #d1ecf1; border-color: #17a2b8; color: #0c5460; }
        .warning { background-color: #fff3cd; border-color: #ffc107; color: #856404; }
        button { 
            padding: 12px 24px; margin: 10px 5px; font-size: 16px; 
            border: none; border-radius: 6px; cursor: pointer;
            background: #007bff; color: white;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px; }
        .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .test-section { border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; }
        .progress { background: #e9ecef; border-radius: 10px; height: 6px; margin: 10px 0; }
        .progress-bar { background: #007bff; height: 100%; border-radius: 10px; transition: width 0.3s; }
    </style>
</head>
<body>
    <h1>ğŸ”§ Complete Stream Error Fix Verification</h1>
    <p>This test verifies that all "Response body stream already read" errors have been fixed in the Netlify integration.</p>
    
    <div class="test-controls">
        <button onclick="runCompleteTest()">ğŸš€ Run Complete Test Suite</button>
        <button onclick="testConnectionMethod()">ğŸ§ª Test Connection Method</button>
        <button onclick="testSiteInfoMethod()">ğŸ“Š Test Site Info Method</button>
        <button onclick="testSequentialCalls()">ğŸ”„ Test Sequential Calls</button>
        <button onclick="clearResults()">ğŸ—‘ï¸ Clear Results</button>
    </div>

    <div class="progress" id="progressContainer" style="display: none;">
        <div class="progress-bar" id="progressBar" style="width: 0%;"></div>
    </div>
    
    <div id="results"></div>

    <script>
        let resultCount = 0;
        let testRunning = false;

        function addResult(type, title, content) {
            const resultsDiv = document.getElementById('results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${type}`;
            resultDiv.innerHTML = `
                <strong>${++resultCount}. ${title}</strong>
                <div>${content}</div>
            `;
            resultsDiv.appendChild(resultDiv);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            resultCount = 0;
            hideProgress();
        }

        function showProgress() {
            document.getElementById('progressContainer').style.display = 'block';
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }

        function setButtonStates(disabled) {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = disabled);
            testRunning = disabled;
        }

        async function callNetlifyFunction(action, expectedMethod) {
            try {
                const response = await fetch('/netlify/functions/add-domain-to-netlify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ action }),
                });

                // Use the FIXED approach: read response text once, regardless of status
                const responseText = await response.text();

                if (!response.ok) {
                    return {
                        success: false,
                        error: `HTTP ${response.status}: ${responseText}`,
                        method: expectedMethod
                    };
                }

                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (jsonError) {
                    return {
                        success: false,
                        error: `Invalid JSON response: ${responseText.substring(0, 200)}`,
                        method: expectedMethod
                    };
                }

                return {
                    success: result.success || false,
                    config: result.config,
                    siteInfo: result.siteInfo,
                    domains: result.domains,
                    error: result.error,
                    method: expectedMethod
                };

            } catch (error) {
                return {
                    success: false,
                    error: error.message,
                    method: expectedMethod,
                    isStreamError: error.message.includes('body stream already read')
                };
            }
        }

        async function testConnectionMethod() {
            if (testRunning) return;
            setButtonStates(true);
            
            addResult('info', 'Testing Connection Method', 'Testing testNetlifyConnection method...');

            try {
                const result = await callNetlifyFunction('test_config', 'testNetlifyConnection');
                
                if (result.isStreamError) {
                    addResult('error', 'âŒ STREAM ERROR DETECTED', `
                        ğŸ’¥ "Response body stream already read" error still present!<br>
                        Method: ${result.method}<br>
                        Error: ${result.error}
                    `);
                } else if (result.success) {
                    addResult('success', 'âœ… Connection Method PASSED', `
                        ğŸ‰ testNetlifyConnection working correctly<br>
                        ğŸ”§ No stream errors detected<br>
                        ğŸ“Š Config Valid: ${result.config?.tokenValid ? 'Yes' : 'No'}<br>
                        ğŸŒ Site: ${result.siteInfo?.name || 'Unknown'}
                    `);
                } else {
                    addResult('warning', 'âš ï¸ Connection Method Issues', `
                        ğŸ”§ No stream errors (GOOD)<br>
                        âŒ But connection failed: ${result.error}<br>
                        ğŸ’¡ Check credentials and configuration
                    `);
                }
            } catch (error) {
                addResult('error', 'ğŸ’¥ Connection Test Crashed', error.message);
            }

            setButtonStates(false);
        }

        async function testSiteInfoMethod() {
            if (testRunning) return;
            setButtonStates(true);
            
            addResult('info', 'Testing Site Info Method', 'Testing getNetlifySiteInfo method...');

            try {
                const result = await callNetlifyFunction('get_site_info', 'getNetlifySiteInfo');
                
                if (result.isStreamError) {
                    addResult('error', 'âŒ STREAM ERROR DETECTED', `
                        ğŸ’¥ "Response body stream already read" error still present!<br>
                        Method: ${result.method}<br>
                        Error: ${result.error}
                    `);
                } else if (result.success) {
                    addResult('success', 'âœ… Site Info Method PASSED', `
                        ğŸ‰ getNetlifySiteInfo working correctly<br>
                        ğŸ”§ No stream errors detected<br>
                        ğŸ“Š Domains Found: ${result.domains?.length || 0}<br>
                        ğŸŒ Site: ${result.siteInfo?.name || 'Unknown'}
                    `);
                } else {
                    addResult('warning', 'âš ï¸ Site Info Method Issues', `
                        ğŸ”§ No stream errors (GOOD)<br>
                        âŒ But request failed: ${result.error}<br>
                        ğŸ’¡ Check credentials and configuration
                    `);
                }
            } catch (error) {
                addResult('error', 'ğŸ’¥ Site Info Test Crashed', error.message);
            }

            setButtonStates(false);
        }

        async function testSequentialCalls() {
            if (testRunning) return;
            setButtonStates(true);
            
            addResult('info', 'Testing Sequential Calls', 'Simulating checkNetlifyConnection behavior...');
            showProgress();

            try {
                const results = [];
                const totalTests = 6;

                // Test 1: Connection
                updateProgress(16);
                addResult('info', 'Sequential Test 1/6', 'Testing testNetlifyConnection...');
                const test1 = await callNetlifyFunction('test_config', 'testNetlifyConnection');
                results.push(test1);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Test 2: Site Info
                updateProgress(33);
                addResult('info', 'Sequential Test 2/6', 'Testing getNetlifySiteInfo...');
                const test2 = await callNetlifyFunction('get_site_info', 'getNetlifySiteInfo');
                results.push(test2);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Test 3-6: Rapid sequential calls
                for (let i = 3; i <= 6; i++) {
                    updateProgress((i / totalTests) * 100);
                    addResult('info', `Sequential Test ${i}/6`, 'Testing rapid sequential calls...');
                    const action = i % 2 === 0 ? 'get_site_info' : 'test_config';
                    const method = i % 2 === 0 ? 'getNetlifySiteInfo' : 'testNetlifyConnection';
                    const result = await callNetlifyFunction(action, method);
                    results.push(result);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                updateProgress(100);

                // Analyze results
                const streamErrors = results.filter(r => r.isStreamError);
                const successes = results.filter(r => r.success);
                const failures = results.filter(r => !r.success && !r.isStreamError);

                if (streamErrors.length > 0) {
                    addResult('error', 'âŒ STREAM ERRORS DETECTED', `
                        ğŸ’¥ ${streamErrors.length} stream errors found!<br>
                        ğŸ”§ The fix is not working correctly<br>
                        ğŸ“‹ Errors: ${streamErrors.map(e => e.method + ': ' + e.error).join(', ')}
                    `);
                } else if (successes.length === results.length) {
                    addResult('success', 'ğŸ‰ ALL SEQUENTIAL TESTS PASSED', `
                        âœ… ${results.length} tests completed successfully<br>
                        ğŸ”§ No stream errors detected<br>
                        ğŸš€ Sequential calling pattern works perfectly<br>
                        ğŸ’ª checkNetlifyConnection should work reliably
                    `);
                } else {
                    addResult('warning', 'âš ï¸ Mixed Results', `
                        ğŸ”§ No stream errors (GOOD)<br>
                        âœ… Successes: ${successes.length}/${results.length}<br>
                        âŒ Failures: ${failures.length}/${results.length}<br>
                        ğŸ’¡ Stream fix works, but check credentials/config
                    `);
                }

            } catch (error) {
                addResult('error', 'ğŸ’¥ Sequential Test Crashed', error.message);
            }

            hideProgress();
            setButtonStates(false);
        }

        async function runCompleteTest() {
            if (testRunning) return;
            
            clearResults();
            addResult('info', 'ğŸš€ Starting Complete Test Suite', 'Running all stream error fix tests...');
            
            await testConnectionMethod();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testSiteInfoMethod();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testSequentialCalls();
            
            addResult('success', 'âœ… Complete Test Suite Finished', `
                ğŸ‰ All tests completed!<br>
                ğŸ“Š Check results above for any remaining issues<br>
                ğŸ’¡ If no stream errors detected, the fix is working correctly
            `);
        }

        // Auto-load message
        document.addEventListener('DOMContentLoaded', function() {
            addResult('info', 'Page Loaded', 'Ready to test complete stream error fixes. Click "ğŸš€ Run Complete Test Suite" to start.');
        });
    </script>
</body>
</html>
